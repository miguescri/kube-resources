#!/bin/bash

MODE_0="m0"
MODE_1="m1"
MODE_2="m2"

finish () {
  # Print the result in a way that makes it possible to diff:
  # - Resources are sorted by name.
  # - If there are resources that share name, they are ordered by kind.
  # - Object keys are sorted alphabetically
  echo $TOTAL | jq 'sort_by(.name, .kind)' -s -S  # -s receives inputs as array, -S sort object keys in output
  exit 0
}

MODE=$1
shift

if ! [[ "$MODE" =~ ^($MODE_0|$MODE_1|$MODE_2)$ ]]; then
  cat <<EOF
$MODE is not a valid working mode

USAGE: $0 MODE FILE_1 FILE_2 ...
If no filenames are provided, will read from standard input

Modes:

- $MODE_0 : raw information from the YAML. Also add minReplicas and maxReplicas values based on Horizontal Pod Autoscalers
- $MODE_1 : top level objects with lists of the underlying container requests and limits
- $MODE_2 : top level objects with the sum of the underlying container requests and limits

EOF

  exit 1
fi


# Translate resources to JSON
JSON_RES=$(yq '.' $@)

# Separate resources by kind
POD=$(echo $JSON_RES | jq 'select(.kind == "Pod")')
RS=$(echo $JSON_RES | jq 'select(.kind == ("Deployment", "ReplicaSet", "StatefulSet", "ReplicationController"))')
HPA=$(echo $JSON_RES | jq 'select(.kind == "HorizontalPodAutoscaler")')

# TODO: think how to manage DaemonSet

# Homogenize the information of Pods and replication controllers
POD=$(echo $POD | jq '{apiVersion, kind, name: .metadata.name, containers: .spec.containers, minReplicas: 1, maxReplicas: 1}')
RS=$(echo $RS | jq '{apiVersion, kind, name: .metadata.name, containers: .spec.template.spec.containers, minReplicas: .spec.replicas, maxReplicas: .spec.replicas}')

# Update replication controllers with the min and max replica values form HorizontalPodAutoscaler
for i in $(echo $HPA | jq -c '.spec') ; do
  FILTER=".apiVersion==$(echo $i | jq -c '.scaleTargetRef.apiVersion') and .kind==$(echo $i | jq -c '.scaleTargetRef.kind') and .name==$(echo $i | jq -c '.scaleTargetRef.name')"
  MAX=$(echo $i | jq '.maxReplicas')
  MIN=$(echo $i | jq '.minReplicas')

  RS=$(echo $RS | jq "(select($FILTER) | . + {maxReplicas: $MAX, minReplicas: $MIN}), select($FILTER | not)")
done

TOTAL=$POD$RS

if [ $MODE == $MODE_0 ]; then
  finish
fi


# Eliminate all the containers information except requests and limits
TOTAL=$(echo $TOTAL | jq '{apiVersion, kind, name, minReplicas, maxReplicas, requests: [(.containers[] | .resources.requests)], limits: [(.containers[] | .resources.limits)]}')
# Put together in arrays all the requests.cpu, requests.memory, limits.cpu and limits.memory
TOTAL=$(echo $TOTAL | jq '{apiVersion, kind, name, minReplicas, maxReplicas, requests: {cpu: [(.requests[] | .cpu)], memory: [(.requests[] | .memory)]}, limits: {cpu: [(.limits[] | .cpu)], memory: [(.limits[] | .memory)]}}')

if [ $MODE == $MODE_1 ]; then
  finish
fi

# Sum the values of requests and limits taking units into consideration
PYTHON_CODE=$(cat <<'EOF'
from pint import UnitRegistry
ureg = UnitRegistry()
text = input().strip().strip('"')  # Accept lines surrounded by quotation marks
result = ureg(text)
print(f'{result:~}')
EOF
)

T=""
for i in $(echo $TOTAL | jq -c '.') ; do
  REQUESTS_CPU=$(echo $i | jq '[(.requests.cpu[] | tostring | .+"s")] | join(" + ")' | python3 -c "$PYTHON_CODE")
  LIMITS_CPU=$(echo $i | jq '[(.limits.cpu[] | tostring | .+"s")] | join(" + ")' | python3 -c "$PYTHON_CODE")
  REQUESTS_MEMORY=$(echo $i | jq '[(.requests.memory[] | tostring | .+"B")] | join(" + ")' | python3 -c "$PYTHON_CODE")
  LIMITS_MEMORY=$(echo $i | jq '[(.limits.memory[] | tostring | .+"B")] | join(" + ")' | python3 -c "$PYTHON_CODE")

  T=$T$(echo $i | jq "{apiVersion, kind, name, minReplicas, maxReplicas, requests: {cpu: \"$REQUESTS_CPU\", memory: \"$REQUESTS_MEMORY\"}, limits: {cpu: \"$LIMITS_CPU\", memory: \"$LIMITS_MEMORY\"}}")
done

TOTAL=$T

if [ $MODE == $MODE_2 ]; then
  finish
fi
